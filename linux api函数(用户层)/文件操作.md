（一）文件操作篇

这是一个关于文件操作的详细说明，涵盖了常用的系统调用和库函数。为了美化和优化这个信息，我们可以将其格式化为表格，以便于更好地理解和查找。以下是整理后的表格形式：


| 函数     1 | 头文件                     1          | 函数签名                  1                                                                                          | 功能描述                         | 返回值                              | 错误代码                                                                                    |
| ------------- | ------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------- | -------------------------------- | ----------------------------------- | ------------------------------------------------------------------------------------------- |
| `creat`       | `<sys/types.h>`<br>`<sys/stat.h>`<br>`<fcntl.h>` | `int creat(const char *pathname, mode_t mode);`                                                                               | 创建一个新文件，返回文件描述词。 | 新的文件描述词，错误时返回-1        | EEXIST, EACCES, EROFS, EFAULT, EINVAL, ENAMETOOLONG, ENOTDIR, ENOMEM, ELOOP, EMFILE, ENFILE |
| `open`        | `<sys/types.h>`<br>`<sys/stat.h>`<br>`<fcntl.h>` | `int open(const char *pathname, int flags);`<br>`int open(const char *pathname, int flags, mode_t mode);`                     | 打开一个文件，返回文件描述词。   | 文件描述词，错误时返回-1            | EEXIST, EACCES, EROFS, EFAULT, EINVAL, ENAMETOOLONG, ENOTDIR, ENOMEM, ELOOP, EIO            |
| `close`       | `<unistd.h>`                                     | `int close(int fd);`                                                                                                          | 关闭一个打开的文件。             | 0表示成功，错误时返回-1             | EBADF                                                                                       |
| `read`        | `<unistd.h>`                                     | `ssize_t read(int fd, void *buf, size_t count);`                                                                              | 从已打开的文件中读取数据。       | 实际读取字节数，错误时返回-1        | EINTR, EAGAIN, EBADF                                                                        |
| `write`       | `<unistd.h>`                                     | `ssize_t write(int fd, const void *buf, size_t count);`                                                                       | 向已打开的文件中写入数据。       | 实际写入字节数，错误时返回-1        | EINTR, EAGAIN, EBADF                                                                        |
| `flock`       | `<sys/file.h>`                                   | `int flock(int fd, int operation);`                                                                                           | 对文件进行锁定或解除锁定。       | 0表示成功，错误时返回-1             | -                                                                                           |
| `lseek`       | `<sys/types.h>`<br>`<unistd.h>`                  | `off_t lseek(int fildes, off_t offset, int whence);`                                                                          | 移动文件的读写位置。             | 当前读写位置，错误时返回-1          | ESPIPE                                                                                      |
| `fcntl`       | `<unistd.h>`<br>`<fcntl.h>`                      | `int fcntl(int fd, int cmd);`<br>`int fcntl(int fd, int cmd, long arg);`<br>`int fcntl(int fd, int cmd, struct flock *lock);` | 操作文件描述词的一些特性。       | 0表示成功，错误时返回-1             | -                                                                                           |
| `fgets`       | `<stdio.h>`                                      | `char *fgets(char *s, int size, FILE *stream);`                                                                               | 从文件中读取字符串。             | 成功返回指针，错误时返回NULL        | -                                                                                           |
| `fputs`       | `<stdio.h>`                                      | `int fputs(const char *s, FILE *stream);`                                                                                     | 将字符串写入文件。               | 成功返回写入字符个数，错误时返回EOF | -                                                                                           |

### 附加说明

- **`creat()`** 无法创建特殊的装置文件，需使用 `mknod()`。
- **`lseek()`** 不适用于 tty 设备，调用会返回 `ESPIPE`。
- **`flock()`** 只能锁定整个文件，无法锁定文件的一部分。
- 建议在进程结束时主动关闭文件，以确保资源的正确释放。

这种表格形式让信息更加清晰易读，便于查找特定函数的功能和相关信息。如果有需要补充或修改的地方，请告诉我！

1、creat（建立文件）

头文件

```
1 #include<sys/types.h>
2 #include<sys/stat.h>
3 #include<fcntl.h>
```

定义函数

```
1 int creat(const char * pathname, mode_tmode);
```

函数说明
参数pathname指向欲建立的文件路径字符串。creat()相当于使用下列的调用方式调用open()

```
1 open(const char * pathname ,(O_CREAT|O_WRONLY|O_TRUNC));
```

错误代码
关于参数mode请参考open（）函数。
返回值
creat()会返回新的文件描述词，若有错误发生则会返回-1，并把错误代码设给errno。
EEXIST 参数pathname所指的文件已存在。
EACCESS 参数pathname 所指定的文件不符合所要求测试的权限
EROFS 欲打开写入权限的文件存在于只读文件系统内
EFAULT 参数pathname 指针超出可存取的内存空间
EINVAL 参数mode 不正确。
ENAMETOOLONG 参数pathname太长。
ENOTDIR 参数pathname为一目录
ENOMEM 核心内存不足
ELOOP 参数pathname有过多符号连接问题。
EMFILE 已达到进程可同时打开的文件数上限
ENFILE 已达到系统可同时打开的文件数上限
附加说明
creat()无法建立特别的装置文件，如果需要请使用mknod()。

2、open（打开文件）
头文件

```
1 #include<sys/types.h>
2 #include<sys/stat.h>
3 #include<fcntl.h>
```

定义函数

```
1 int open( const char * pathname, int flags);
2 int open( const char * pathname,int flags, mode_t mode);
```

函数说明
参数pathname 指向欲打开的文件路径字符串。下列是参数flags 所能使用的旗标:
O\_RDONLY 以只读方式打开文件
O\_WRONLY 以只写方式打开文件
O\_RDWR 以可读写方式打开文件。上述三种旗标是互斥的，也就是不可同时使用，但可与下列的旗标利用OR(|)运算符组合。
O\_CREAT 若欲打开的文件不存在则自动建立该文件。
O\_EXCL 如果O\_CREAT 也被设置，此指令会去检查文件是否存在。文件若不存在则建立该文件，否则将导致打开文件错误。此外，若O\_CREAT与O\_EXCL同时设置，并且欲打开的文件为符号连接，则会打开文件失败。
O\_NOCTTY 如果欲打开的文件为终端机设备时，则不会将该终端机当成进程控制终端机。
O\_TRUNC 若文件存在并且以可写的方式打开时，此旗标会令文件长度清为0，而原来存于该文件的资料也会消失。
O\_APPEND 当读写文件时会从文件尾开始移动，也就是所写入的数据会以附加的方式加入到文件后面。
O\_NONBLOCK 以不可阻断的方式打开文件，也就是无论有无数据读取或等待，都会立即返回进程之中。
O\_NDELAY 同O\_NONBLOCK。
O\_SYNC 以同步的方式打开文件。
O\_NOFOLLOW 如果参数pathname 所指的文件为一符号连接，则会令打开文件失败。
O\_DIRECTORY 如果参数pathname 所指的文件并非为一目录，则会令打开文件失败。
此为Linux2.2以后特有的旗标，以避免一些系统安全问题。参数mode 则有下列数种组合，只有在建立新文件时才会生效，此外真正建文件时的权限会受到umask值所影响，因此该文件权限应该为（mode-umaks）。
S\_IRWXU00700 权限，代表该文件所有者具有可读、可写及可执行的权限。
S\_IRUSR 或S\_IREAD，00400权限，代表该文件所有者具有可读取的权限。
S\_IWUSR 或S\_IWRITE，00200 权限，代表该文件所有者具有可写入的权限。
S\_IXUSR 或S\_IEXEC，00100 权限，代表该文件所有者具有可执行的权限。
S\_IRWXG 00070权限，代表该文件用户组具有可读、可写及可执行的权限。
S\_IRGRP 00040 权限，代表该文件用户组具有可读的权限。
S\_IWGRP 00020权限，代表该文件用户组具有可写入的权限。
S\_IXGRP 00010 权限，代表该文件用户组具有可执行的权限。
S\_IRWXO 00007权限，代表其他用户具有可读、可写及可执行的权限。
S\_IROTH 00004 权限，代表其他用户具有可读的权限
S\_IWOTH 00002权限，代表其他用户具有可写入的权限。
S\_IXOTH 00001 权限，代表其他用户具有可执行的权限。
返回值
若所有欲核查的权限都通过了检查则返回0 值，表示成功，只要有一个权限被禁止则返回-1。
错误代码
EEXIST 参数pathname 所指的文件已存在，却使用了O\_CREAT和O\_EXCL旗标。
EACCESS 参数pathname所指的文件不符合所要求测试的权限。
EROFS 欲测试写入权限的文件存在于只读文件系统内。
EFAULT 参数pathname指针超出可存取内存空间。
EINVAL 参数mode 不正确。
ENAMETOOLONG 参数pathname太长。
ENOTDIR 参数pathname不是目录。
ENOMEM 核心内存不足。
ELOOP 参数pathname有过多符号连接问题。
EIO I/O 存取错误

3、close（关闭文件）

头文件

```
1 #include<unistd.h>
```

定义函数

```
1 int close(int fd);
```

函数说明

当使用完文件后若已不再需要则可使用close()关闭该文件，二close()会让数据写回磁盘，并释放该文件所占用的资源。参数fd为先前由open()或creat()所返回的文件描述词。
返回值
若文件顺利关闭则返回0，发生错误时返回-1。
错误代码
EBADF 参数fd 非有效的文件描述词或该文件已关闭。
附加说明
虽然在进程结束时，系统会自动关闭已打开的文件，但仍建议自行关闭文件，并确实检查返回值。

4、read（由已打开的文件读取数据）

头文件

```
1 #include<unistd.h>
```

定义函数

```
1 ssize_t read(int fd,void * buf ,size_t count);
```

函数说明

read()会把参数fd 所指的文件传送count个字节到buf指针所指的内存中。若参数count为0，则read()不会有作用并返回0。返回值为实际读取到的字节数，如果返回0，表示已到达文件尾或是无可读取的数据，此外文件读写位置会随读取到的字节移动。
附加说明
如果顺利read()会返回实际读到的字节数，最好能将返回值与参数count 作比较，若返回的字节数比要求读取的字节数少，则有可能读到了文件尾、从管道(pipe)或终端机读取，或者是read()被信号中断了读取动作。当有错误发生时则返回-1，错误代码存入errno中，而文件读写位置则无法预期。
错误代码
EINTR 此调用被信号所中断。
EAGAIN 当使用不可阻断I/O 时（O\_NONBLOCK），若无数据可读取则返回此值。
EBADF 参数fd 非有效的文件描述词，或该文件已关闭。

5、write（将数据写入已打开的文件内）

头文件

```
1 #include<unistd.h>
```

定义函数

```
1 ssize_t write (int fd,const void * buf,size_t count);
```

函数说明

write()会把参数buf所指的内存写入count个字节到参数fd所指的文件内。当然，文件读写位置也会随之移动。
返回值
如果顺利write()会返回实际写入的字节数。当有错误发生时则返回-1，错误代码存入errno中。
错误代码
EINTR 此调用被信号所中断。
EAGAIN 当使用不可阻断I/O 时（O\_NONBLOCK），若无数据可读取则返回此值。
EADF 参数fd非有效的文件描述词，或该文件已关闭。

6、flock（锁定文件或解除锁定）

头文件

```
1 #include<sys/file.h>
```

定义函数

```
1 int flock(int fd,int operation);
```

函数说明

flock()会依参数operation所指定的方式对参数fd所指的文件做各种锁定或解除锁定的动作。此函数只能锁定整个文件，无法锁定文件的某一区域。
参数
operation有下列四种情况:
LOCK\_SH 建立共享锁定。多个进程可同时对同一个文件作共享锁定。
LOCK\_EX 建立互斥锁定。一个文件同时只有一个互斥锁定。
LOCK\_UN 解除文件锁定状态。
LOCK\_NB 无法建立锁定时，此操作可不被阻断，马上返回进程。通常与LOCK\_SH或LOCK\_EX 做OR(|)组合。
单一文件无法同时建立共享锁定和互斥锁定，而当使用dup()或fork()时文件描述词不会继承此种锁定。
返回值
返回0表示成功，若有错误则返回-1，错误代码存于errno。

7、lseek（移动文件的读写位置）

头文件

```
1 #include<sys/types.h>
2 #include<unistd.h>
```

定义函数

```
1 off_t lseek(int fildes,off_t offset ,int whence);
```

函数说明

每一个已打开的文件都有一个读写位置，当打开文件时通常其读写位置是指向文件开头，若是以附加的方式打开文件(如O\_APPEND)，则读写位置会指向文件尾。当read()或write()时，读写位置会随之增加，lseek()便是用来控制该文件的读写位置。参数fildes 为已打开的文件描述词，参数offset 为根据参数whence来移动读写位置的位移数。
参数
whence为下列其中一种:
SEEK\_SET 参数offset即为新的读写位置。
SEEK\_CUR 以目前的读写位置往后增加offset个位移量。
SEEK\_END 将读写位置指向文件尾后再增加offset个位移量。
当whence 值为SEEK\_CUR 或SEEK\_END时，参数offet允许负值的出现。
下列是教特别的使用方式:

1) 欲将读写位置移到文件开头时:lseek（int fildes,0,SEEK\_SET）；
2) 欲将读写位置移到文件尾时:lseek（int fildes，0,SEEK\_END）；
3) 想要取得目前文件位置时:lseek（int fildes，0,SEEK\_CUR）；
   返回值
   当调用成功时则返回目前的读写位置，也就是距离文件开头多少个字节。若有错误则返回-1，errno 会存放错误代码。
   附加说明
   Linux系统不允许lseek（）对tty装置作用，此项动作会令lseek（）返回ESPIPE。

8、fcntl（文件描述词操作）

头文件

```
1 #include<unistd.h>
2 #include<fcntl.h>
```

定义函数

```
1 int fcntl(int fd , int cmd);
2 int fcntl(int fd,int cmd,long arg);
3 int fcntl(int fd,int cmd,struct flock * lock);
```

函数说明

fcntl()用来操作文件描述词的一些特性。参数fd代表欲设置的文件描述词，参数cmd代表欲操作的指令。
有以下几种情况:
F\_DUPFD用来查找大于或等于参数arg的最小且仍未使用的文件描述词，并且复制参数fd的文件描述词。执行成功则返回新复制的文件描述词。请参考 dup2()。F\_GETFD取得close-on-exec旗标。若此旗标的FD\_CLOEXEC位为0，代表在调用exec()相关函数时文件将不会关闭。
F\_SETFD 设置close-on-exec 旗标。该旗标以参数arg 的FD\_CLOEXEC位决定。
F\_GETFL 取得文件描述词状态旗标，此旗标为open（）的参数flags。
F\_SETFL 设置文件描述词状态旗标，参数arg为新旗标，但只允许O\_APPEND、O\_NONBLOCK和O\_ASYNC位的改变，其他位的改变将不受影响。
F\_GETLK 取得文件锁定的状态。
F\_SETLK 设置文件锁定的状态。此时flcok 结构的l\_type 值必须是F\_RDLCK、F\_WRLCK或F\_UNLCK。如果无法建立锁定，则返回-1，错误代码为EACCES 或EAGAIN。
F\_SETLKW F\_SETLK 作用相同，但是无法建立锁定时，此调用会一直等到锁定动作成功为止。若在等待锁定的过程中被信号中断时，会立即返回-1，错误代码为EINTR。参数lock指针为flock 结构指针，定义如下

[![复制代码](https://assets.cnblogs.com/images/copycode.gif)]("复制代码")

```
1 struct flcok
2 {
3     short int l_type; /* 锁定的状态*/
4     short int l_whence;/*决定l_start位置*/
5     off_t l_start; /*锁定区域的开头位置*/
6     off_t l_len; /*锁定区域的大小*/
7     pid_t l_pid; /*锁定动作的进程*/
8 };
```

[![复制代码](https://assets.cnblogs.com/images/copycode.gif)]("复制代码")

l\_type 有三种状态:

F\_RDLCK 建立一个供读取用的锁定
F\_WRLCK 建立一个供写入用的锁定
F\_UNLCK 删除之前建立的锁定
l\_whence 也有三种方式:
SEEK\_SET 以文件开头为锁定的起始位置。
SEEK\_CUR 以目前文件读写位置为锁定的起始位置
SEEK\_END 以文件结尾为锁定的起始位置。
返回值
成功则返回0，若有错误则返回-1，错误原因存于errno.

9、fgets（由文件中读取一字符串）

头文件

```
1 include<stdio.h>
```

定义函数

```
1 char * fgets(char * s,int size,FILE * stream);
```

函数说明

fgets()用来从参数stream所指的文件内读入字符并存到参数s所指的内存空间，直到出现换行字符、读到文件尾或是已读了size-1个字符为止，最后会加上NULL作为字符串结束。
返回值
gets()若成功则返回s指针，返回NULL则表示有错误发生。

10、fputs（将一指定的字符串写入文件内）

头文件

```
1 #include<stdio.h>
```

定义函数

```
1 int fputs(const char * s,FILE * stream);
```

函数说明

fputs()用来将参数s所指的字符串写入到参数stream所指的文件内。
返回值
若成功则返回写出的字符个数，返回EOF则表示有错误发生。
